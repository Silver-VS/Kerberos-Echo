# SecretVault – Keystore and Key Lifecycle

This document explains how the project stores, names and uses cryptographic keys
on disk through the `Security/SecretVault` directory.

SecretVault is a very simple, file-based keystore. Every role
(Client, AS, TGS, Server) reads and writes its keys here in order to:

- Persist RSA key pairs (public/private) for each role.
- Persist symmetric DES keys shared between two roles.
- Persist session keys created during the Kerberos exchanges.

It is intentionally transparent and easy to inspect for learning purposes.

> **Single-VM vs distributed deployment**
>
> In the single-VM demo, all roles share the same project tree and a single
> `Security/SecretVault` directory. This is convenient for exploration, because
> you can see *all* keys in one place.
>
> In a **real multi-node setup**, each machine (AS, TGS, Server, Client) has its
> **own** SecretVault (own filesystem) and only sees its *own* RSA keys and its
> *own* symmetric keys for the relationships it participates in. You would not
> copy the entire “global” SecretVault everywhere.
> 
> You can simulate the multi-node setup in a single-VM just by changing where the actors 
> save and retrieve their keys.

---

## 1. Directory layout

Under `src/main/java/Security/SecretVault` there are two key directories:

```text
Security/SecretVault
├── Generated/
└── Connection/
```

----

### 1.1 `Generated/`

This directory contains keys that a role generates locally, such as:

- RSA keypair for that role:

    - `publicAS.key`, `privateAS.key`

    - `publicClient.key`, `privateClient.key`

    - `publicTGS.key`, `privateTGS.key`

    - `publicServer.key`, `privateServer.key`

- Some symmetric DES keys created during Kerberos flows (e.g. session keys `K_c,tgs`, `K_c,s` on the server side).

It is populated by:

- `Controllers.Distributor.<Role>.KeyCreation`

- Some `ProcessRequest` implementations (AS, TGS) via `KeyMethods.saveSecret(...)`.

### 1.2 `Connection/`

This directory contains keys that a role uses for communication with others:

- Long-term symmetric DES keys shared between roles:

    - `Symmetric-AS-Client.key`

    - `Symmetric-AS-TGS.key`

    - `Symmetric-TGS-Server.key`

    - `Symmetric-Client-AS.key`

    - `Symmetric-Client-TGS.key`

    - `Symmetric-Client-Server.key`

    - etc.

- Copies of public keys received from other roles:

    - `publicClientReceived.key`

    - `publicServerReceived.key`

    - `publicTGSReceived.key`

    - (and similar for other roles if needed)

It is populated by:

- `Model.KeyDistributor.receiver(...)`
  (receives remote public key, generates symmetric key, stores both)

- `Model.KeyDistributor.publicSenderSecretReceiver(...)`
  (receives the encrypted symmetric key and stores it)

- Kerberos `ProcessRequest` methods when they persist session keys for reuse.

On a fresh clone, both `Generated/` and `Connection/` are expected to be empty.
The first runs of `KeyCreation` and Distributor Sender/Receiver fill them.

In a distributed setup, each node’s `Connection/` contains only the symmetric
keys that node needs, e.g.:

- On the AS machine: keys like `Symmetric-AS-Client.key`, `Symmetric-AS-TGS.key`.

- On the Client machine: `Symmetric-Client-AS.key`, `Symmetric-Client-TGS.key`, etc.

----

## 2. Where paths are configured

Each controller computes SecretVault paths from projectPath.

Example (TGS controller):

```java
int receivingPort = 1202;
String projectPath = "Disk:\\Path";

String path4SecretKeyRetrieving =
    projectPath + "\\src\\main\\java\\Security\\SecretVault\\Connection\\";
String path4SecretKeySaving =
    projectPath + "\\src\\main\\java\\Security\\SecretVault\\Generated\\";
```

Typical conventions:

- `path4SecretKeySaving` → where this role stores locally generated keys (`Generated/`).

- `path4SecretKeyRetrieving` → where this role looks for communication keys (`Connection/`).

In the single-VM demo, these paths point to a shared SecretVault tree.

In a distributed setup, each machine has its own `projectPath` and therefore
its own local `SecretVault` directories.

----

## 3. Key types and naming conventions

### 3.1 RSA key pairs

Each role has its own RSA key pair, generated by:

```java
KeyMethods.keyCreator(directoryPath, "AS");
```

Internally (`KeyMethods.keyCreator`):

Uses `KeyPairGenerator.getInstance("RSA")`.

Writes two files in `Generated/`:

    publicAS.key
    privateAS.key

General pattern:

    public<Role>.key
    private<Role>.key

where `<Role>` ∈ {AS, Client, TGS, Server}.

On a multi-node deployment, each node only has its own `<Role>` key pair.
You never need `publicClient.key` / `privateClient.key` on the AS machine, for example.

These files are the long-term identity keys of each role. In this project,
they are used only in the Distributor phase to bootstrap symmetric keys.

### 3.2 Symmetric DES keys

Symmetric keys are generated and stored using KeyMethods:

```java
// Generate a DES key
SecretKey key = KeyMethods.generateSecretKey();

// Save with a naming convention: Symmetric-<Owner>-<WithWho>.key
KeyMethods.saveSecret(key, path, "AS", "Client");
```

The file name is:

    Symmetric-<Owner>-<WithWho>.key


`<Owner>` – who is storing and using this file locally (this node/role).

`<WithWho>` – which other role this key is shared with.

For a given relationship (e.g. AS–Client) there will be two physical files,
one on each side, both files containing the same DES key bytes, but each is 
stored from the local perspective of its owner:

- On the AS machine: `Symmetric-AS-Client.key`

- On the Client machine: `Symmetric-Client-AS.key`


In the single-VM demo, you might see both files together under the same
Connection/ directory because all roles share one tree. In a distributed
deployment, those files would live on different machines.

### 3.3 Received public keys

In the Distributor phase, when a node receives someone else’s public key, it is
stored as:

```java
KeyMethods.saveKey(publicKey, path4KeySaving, whoIsSending + "Received", true);
```

which produces files such as:

    publicClientReceived.key
    publicServerReceived.key
    publicTGSReceived.key

These are trusted local copies of other roles’ public keys, stored in
`Connection/`.

Again:

- In the single-VM demo, you may see several public*Received.key files
together under one Connection/.

- In a distributed setup, each node only has the public*Received.key files
it actually received during its own Distributor handshake.

----

## 4. Key lifecycle

### 4.1 Initial RSA generation

For each role, you run its `KeyCreation` class once:

```java
// Example: Controllers.Distributor.AS.KeyCreation
String projectPath = "...";
String path4Keys = projectPath + "\\src\\main\\java\\Security\\SecretVault\\Generated\\";
KeyMethods.keyCreator(path4Keys, "AS");
```

Which:

1. Generates a new RSA key pair.

2. Writes `publicAS.key` and `privateAS.key` under `Generated/`.

Running `KeyCreation` again with the same role name will **overwrite** the
existing files for that role.

In a distributed setup you run `KeyCreation` on each machine, but only for
the role that machine hosts:

- On the AS machine → run `AS.KeyCreation`.

- On the TGS machine → run `TGS.KeyCreation`.

- etc.

### 4.2 Distributor phase – establishing symmetric keys

The Distributor phase uses `Model.KeyDistributor` and `Model.Messenger` to:

- Exchange public keys over the network.

- Create and distribute symmetric DES keys.

It always follows the pattern:

1. Receiver role:

- Start `Controllers.Distributor.<Role>.Receiver` first.
    
     Code structure (example TGS):
     ```java
     ServerSocket serverSocket = new ServerSocket(5501);
     String whoAmI = "TGS";
     String senderName = "Server";
     String path4KeySaving = projectPath + "\\...\\SecretVault\\Connection\\";
        
     KeyDistributor.receiver(serverSocket, senderName, whoAmI, path4KeySaving);
     ```
- `KeyDistributor.receiver(...)`:
    
  - Accepts a connection from the Sender.
    
  - Receives the remote public key via `Messenger.receivePublic(...)`.
    
  - Saves it as `public<SenderName>Received.key` in `Connection/`.
    
  - Generates a new `SecretKey` (DES).
    
  - Saves it as `Symmetric-<whoAmI>-<senderName>.key` in `Connection/`.
    
-   Sends this symmetric key back encrypted with the received public key.

2. Sender role:

- Start `Controllers.Distributor.<Role>.Sender` after the Receiver is listening.

  Code structure (example TGS → AS):
     ```java
    String whoAmI = "TGS";
    String receiverHost = "localhost";
    int connectionPort = 5521;
    String receiverName = "AS";
    String path4KeyRetrieval = projectPath + "\\...\\SecretVault\\Generated\\";
    String path4KeySaving    = projectPath + "\\...\\SecretVault\\Connection\\";

    KeyDistributor.publicSenderSecretReceiver(
        receiverHost, connectionPort, receiverName, whoAmI,
        path4KeyRetrieval, path4KeySaving
    );
     ```

- `KeyDistributor.publicSenderSecretReceiver(...)`:
    
  - Opens a `Socket` to the receiver.
    
  - Loads its own `public<whoAreYou>.key` and `private<whoAreYou>.key` from `Generated/`.
    
  - Calls `Messenger.sendPublicReceiveSecret(...)` to:
    
    - Send its public key to the receiver.
    
    - Receive an encrypted symmetric key.
    
    - Decrypt it with its private key.
    
  - Saves the resulting DES key as `Symmetric-<whoAreYou>-<whosResponding>.key` in `Connection/`.

After both sides complete this handshake:

- Each has its own local symmetric file (with different names) that contain
identical key bytes.

- Asymmetric RSA keys are no longer used in the Kerberos phase; only symmetric keys are.

Repeat this pattern for each required pair:

1. AS ↔ Client

2. AS ↔ TGS

3. TGS ↔ Server

(And any others you want to add.)

In the single-VM demo, it may look as though “all keys are in one place”.
Conceptually, each pair of symmetric files represents what would live on two
different machines in a real deployment.

----

#### 4.3 Kerberos phase – using and creating keys

Once Distributor setup is done, the Kerberos controllers retrieve keys from
SecretVault using `KeyMethods`:

##### Retrieving long-term symmetric keys

Typical call:

```java
SecretKey secretAS_Client = KeyMethods.recoverSecret(path4KeyRetrieving, "AS", "Client");
// Maps to file: path4KeyRetrieving + "Symmetric-AS-Client.key"
```

>The pattern: `SecretKey recoverSecret(String path, String whoAreYou, String withWho);`
>
>constructs: `<path> + "Symmetric-" + whoAreYou + "-" + withWho + ".key"`

So:

`recoverSecret(path, "AS", "Client")` → `Symmetric-AS-Client.key`

`recoverSecret(path, "Client", "AS")` → `Symmetric-Client-AS.key`

These are the long-term shared keys (AS–Client, AS–TGS, TGS–Server, etc.)
used to:

- Decrypt tickets issued by other roles.

- Encrypt tickets intended for them.

##### Creating and saving session keys

During AS and TGS processing, new session keys are generated for client
communications:

In `AS.ProcessRequest`:
```java
SecretKey sessionKeyClientTGS = KeyMethods.generateSecretKey();
KeyMethods.saveSecret(sessionKeyClientTGS, path4KeySaving, "Client", "TGS");
```

This produces a file like:

    Symmetric-Client-TGS.key

From the AS perspective, this is the session key that will later be used
between Client and TGS. The same key is also placed in the ticket (`key`
field) so it can be reconstructed by the other parties when needed.

In TGS.ProcessRequest:
```java
SecretKey sessionKeyClient_Server = KeyMethods.generateSecretKey();
KeyMethods.saveSecret(sessionKeyClient_Server, path4KeySaving, "Client", "Server");
```

Leading to:

    Symmetric-Client-Server.key

At the same time, when a role recovers a session key from a ticket, it often
saves its own local copy in `Connection/` with its own `<Owner>-<WithWho>`
perspective, using `saveSecret(...)`.

----

## 5. Multi-node considerations

In a multi-node setup (AS, TGS, Server, Client each on different machines):

1. Each machine has its own Security/SecretVault/Generated and
Security/SecretVault/Connection directories.

2. You do not copy the entire SecretVault from one node to another.
Instead:

   - Each node runs its own KeyCreation for its role.

   - Each pair of nodes runs the Distributor Sender/Receiver handshake to
   establish a shared symmetric key.

>Concretely:
>
>>- On the AS machine:
>>
>>  - `Generated/` contains `publicAS.key` / `privateAS.key`.
>>
>>  - `Connection/` contains keys involving AS: `Symmetric-AS-Client.key`,
>>  `Symmetric-AS-TGS.key`, and `publicClientReceived.key`, `publicTGSReceived.key`, etc.
>
>>- On the Client machine:
>>
>>  - `Generated/` contains `publicClient.key` / `privateClient.key`.
>>
>>  - `Connection/` contains `Symmetric-Client-AS.key`, `Symmetric-Client-TGS.key`, etc.
>
>>- On the TGS machine:
>>
>>  - `Generated/` contains `publicTGS.key` / `privateTGS.key`.
>>
>>  - `Connection/` contains `Symmetric-TGS-AS.key`, `Symmetric-TGS-Server.key`, etc.
>
>>- On the Server machine:
>>
>>  - `Generated/` contains `publicServer.key` / `privateServer.key`.
>>
>>  - `Connection/` contains `Symmetric-Server-TGS.key`, `Symmetric-Server-Client.key` (if saved), etc.

In the single-VM demo, all of these appear together under one SecretVault
tree for convenience, but conceptually you should imagine them split across
four machines.

----

## 6. Common failure modes and troubleshooting

### 6.1 Missing keys (`NullPointerException` / decryption errors)

> Symptoms:
>
> `recoverSecret(...)` throws or returns `null`.
>
> Ticket decryption fails with a stack trace.

Likely causes:

- `KeyCreation` was not run for that role → RSA files missing in `Generated/`.

- Distributor Sender/Receiver for that pair was never run → symmetric files
missing in `Connection/`.

- `projectPath` or SecretVault paths in controllers do not point to the correct
directories on this machine.

- In a distributed scenario, you are pointing to the wrong local project tree.

Checklist:

1. Confirm that `public<Role>.key` and `private<Role>.key` exist in `Generated/`
on the correct machine.

2. Confirm that the expected `Symmetric-<Owner>-<WithWho>.key` file exists in
`Connection/` for the complaining role.

3. Confirm that `projectPath` and derived paths are correct for your environment.

### 6.2 Mismatched keys

>Symptoms:
>
>Both sides have `Symmetric-*` files, but decryption fails or tickets are
rejected.

Likely causes:

- Distributor phase was run with a different set of RSA keys, then roles’
RSA keys were re-generated without re-running Distributor.

- Connection files from a previous run were left in place while RSA keys
were changed.

- In distributed mode, SecretVaults were copied across machines, leading to
inconsistent combinations of RSA and symmetric keys.

Solution:

- On each machine:

  - Delete all `Symmetric-*` files and `public*Received.key` files from
  `Connection/`.

  - Optionally delete and regenerate `public*.key` / `private*.key` in
  `Generated/`.

- Re-run:

  1. All `KeyCreation` mains (per role/machine).

  2. All Distributor Sender/Receiver pairs (per relationship).

### 6.3 Stale or inconsistent session keys

Since session keys (`K_c,tgs`, `K_c,s`, etc.) can also be stored with
`saveSecret(...)`, stale files may exist after multiple runs.

If unexpected behavior occurs during Kerberos exchanges:

- Clean up `Symmetric-Client-*.key` and `Symmetric-*-Client.key` files.

- Re-run the protocol from the beginning with a clean `SecretVault` state.

----

## 7. Security notes

> `SecretVault` is designed for transparency and learning, not security:

- Keys are stored in clear form on disk (though key material is binary and
sometimes Base64-encoded).

- There is no OS-level keystore, hardware security module or access control.

- There is no key rotation, revocation or audit trail.

- File names reveal relationships (Symmetric-AS-Client.key, etc.).

In a real system, you would replace SecretVault with:

- A proper keystore (e.g. Java KeyStore, HSM, KMS).

- Secure key derivation from user credentials.

- Stronger algorithms than DES and more robust key management practices.

Here, the goal is to make it easy to:

- See which keys exist, and when they are created.

- Trace which keys are used by each role at each step of the Kerberos-style
protocol.